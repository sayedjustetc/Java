/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
const vscode_1 = require("vscode");
const vscode_languageserver_protocol_1 = require("vscode-languageserver-protocol");
class WorkspaceFoldersFeature {
    constructor(_client) {
        this._client = _client;
        this._listeners = new Map();
    }
    get messages() {
        return vscode_languageserver_protocol_1.DidChangeWorkspaceFolders.type;
    }
    fillInitializeParams(params) {
        let proposedParams = params;
        let folders = vscode_1.workspace.workspaceFolders;
        if (folders === void 0) {
            proposedParams.workspaceFolders = null;
        }
        else {
            proposedParams.workspaceFolders = folders.map(folder => this.asProtocol(folder));
        }
    }
    fillClientCapabilities(capabilities) {
        capabilities.workspace = capabilities.workspace || {};
        let workspace = capabilities.workspace;
        workspace.workspaceFolders = true;
    }
    initialize() {
        let client = this._client;
        client.onRequest(vscode_languageserver_protocol_1.GetWorkspaceFolders.type, (token) => {
            let workspaceFolders = () => {
                let folders = vscode_1.workspace.workspaceFolders;
                if (folders === void 0) {
                    return null;
                }
                let result = folders.map((folder) => {
                    return this.asProtocol(folder);
                });
                return result;
            };
            let middleware = this.getWorkspaceFolderMiddleware();
            return middleware.workspaceFolders
                ? middleware.workspaceFolders(token, workspaceFolders)
                : workspaceFolders(token);
        });
        client.onRequest(vscode_languageserver_protocol_1.GetWorkspaceFolder.type, (uri, token) => {
            let workspaceFolder = (uri) => {
                let folder = vscode_1.workspace.getWorkspaceFolder(client.protocol2CodeConverter.asUri(uri));
                if (folder === void 0) {
                    return null;
                }
                return this.asProtocol(folder);
            };
            let middleware = this.getWorkspaceFolderMiddleware();
            return middleware.workspaceFolder
                ? middleware.workspaceFolder(uri, token, workspaceFolder)
                : workspaceFolder(uri, token);
        });
    }
    register(_message, data) {
        let id = data.id;
        let disposable = vscode_1.workspace.onDidChangeWorkspaceFolders((event) => {
            let didChangeWorkspaceFolders = (event) => {
                let params = {
                    event: {
                        added: event.added.map(folder => this.asProtocol(folder)),
                        removed: event.removed.map(folder => this.asProtocol(folder))
                    }
                };
                this._client.sendNotification(vscode_languageserver_protocol_1.DidChangeWorkspaceFolders.type, params);
            };
            let middleware = this.getWorkspaceFolderMiddleware();
            middleware.didChangeWorkspaceFolders
                ? middleware.didChangeWorkspaceFolders(event, didChangeWorkspaceFolders)
                : didChangeWorkspaceFolders(event);
        });
        this._listeners.set(id, disposable);
    }
    unregister(id) {
        let disposable = this._listeners.get(id);
        if (disposable === void 0) {
            return;
        }
        this._listeners.delete(id);
        disposable.dispose();
    }
    dispose() {
        for (let disposable of this._listeners.values()) {
            disposable.dispose();
        }
        this._listeners.clear();
    }
    asProtocol(workspaceFolder) {
        if (workspaceFolder === void 0) {
            return null;
        }
        return { uri: this._client.code2ProtocolConverter.asUri(workspaceFolder.uri), name: workspaceFolder.name };
    }
    getWorkspaceFolderMiddleware() {
        let middleware = this._client.clientOptions.middleware;
        return middleware && middleware.workspace
            ? middleware.workspace
            : {};
    }
}
exports.WorkspaceFoldersFeature = WorkspaceFoldersFeature;
class ConfigurationFeature {
    constructor(_client) {
        this._client = _client;
    }
    fillClientCapabilities(capabilities) {
        capabilities.workspace = capabilities.workspace || {};
        let workspace = capabilities.workspace;
        workspace.configuration = true;
    }
    initialize() {
        let client = this._client;
        client.onRequest(vscode_languageserver_protocol_1.GetConfigurationRequest.type, (params, token) => {
            let configuration = (params) => {
                let result = [];
                for (let item of params.items) {
                    let resource = item.scopeUri !== void 0 && item.scopeUri !== null ? this._client.protocol2CodeConverter.asUri(item.scopeUri) : undefined;
                    result.push(this.getConfiguration(resource, item.section !== null ? item.section : undefined));
                }
                return result;
            };
            let middleware = this.getConfigurationMiddleware();
            return middleware.configuration
                ? middleware.configuration(params, token, configuration)
                : configuration(params, token);
        });
    }
    getConfiguration(resource, section) {
        let result = null;
        if (section) {
            let index = section.lastIndexOf('.');
            if (index === -1) {
                result = vscode_1.workspace.getConfiguration(undefined, resource).get(section);
            }
            else {
                let config = vscode_1.workspace.getConfiguration(section.substr(0, index));
                if (config) {
                    result = config.get(section.substr(index + 1));
                }
            }
        }
        else {
            let config = vscode_1.workspace.getConfiguration(undefined, resource);
            result = {};
            for (let key of Object.keys(config)) {
                if (config.has(key)) {
                    result[key] = config.get(key);
                }
            }
        }
        if (!result) {
            return null;
        }
        return result;
    }
    getConfigurationMiddleware() {
        let middleware = this._client.clientOptions.middleware;
        return middleware && middleware.workspace
            ? middleware.workspace
            : {};
    }
}
exports.ConfigurationFeature = ConfigurationFeature;
function ProposedProtocol(client) {
    let result = [];
    result.push(new WorkspaceFoldersFeature(client));
    result.push(new ConfigurationFeature(client));
    return result;
}
exports.ProposedProtocol = ProposedProtocol;
